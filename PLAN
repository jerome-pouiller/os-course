A ajouter:
  - argc/argv
  - read, open, write et les filedescriptor
  - diff/patch

  Objectif: Découvrir les systèmes d'exploitation en se basant sur Linux.
  Pedagogie: On apprend à utiliser Linxu et on généralise certaines connaissance.

Jamais de commentaires: ca a été dur à écrire, ca doit ête dur à comprendre.

  - Les Grandes classes d'OS moderne (== Posix?) -> Il faut juste expliquer ce qu'est Posix et y revenir plus tard -> 10min
     - Posix, embarqué ou non
     - Les non-Posix, embarqué ou non
     - Cygwin
     - Pourquoi Linux? 
       - Generique et generaliste : systeme embarqué -> suprcalculateur
       - Pedagogique car ouvert
       - Bonne application des standard -> Beaucoup d'autre OS n'ont qu'une sous ensemble de ses fonctionnalités
      - Il domine le marché: 
           * entre 20M et 60M de PC sous Linux
           * 200M de terminaux Android
           * Google : 1M servers sous Linux
           * 30M (60% des 50M) de serveur dans le monde
           * 99% des supercalculateur
           * 30M de box en France 
           * Le materiel medical, les tv, les lecteur de dvd, les appareils photos, etc...
           * j'ai personnellement embarqué linux dans une station nucléaire, un portail d'aeroport, un satellite, des calculateur 3D, des régies TV, les routeur réseau, des modem ADSL, des boitier multimédia.
           * A comparer avec 1000M de PC (sous Windows)
    - Liste d'OS -> nous y reviendrons lorsque nous aurons pris un peu de recul
      - Windows, Linux, VxWorks, MacOSX, Android, (cf chronologie), psos, ecos, rtos, ucosII, msdos, *BSD, SysV, 
  - Shell -> 2h
    - Historique: une des premier maniere de communique avec la machine (1970)
    - Plus ou moins normalisé, différentes implémentations, fonctionnent sur les *nix (Linux, android, iOS, OS compatibles Posix)
    - Obtenir un shell -------------------------------> A revoir
      - Il faut un terminal:
        - xterm, gnuterm, konsole
        - Ctrl+Alt+F
    - Les différents shell (avec leurs historiques)
    - Lancer une commande
    - Les chemins
      - absolu
      - relatif
      - Le repertoire courants: pwd, cd
    - Séparation par des espaces
      - ARGC ARGV
    - Les options longues/courtes
      - getopts
    - Les commandes Posix
    - Le PATH
      - execve, ARGV[0]
    - Lancer une binaire locale
    - Les coreutils: ls, ls -l, cat, cat -e, cat -n, 
    - La commande ``file'', les type mimes, les extentions
    - Les redirection: 
       - e/s standards
       - Les file descriptor
       - > < | << EOF
       - ls reagit differement avec une redirection: colonne, couleurs
    - Les variables:
       - Affectation, concatenation
       - variable locales
       - Vairable d'enviornnement
         - execvep (avec l'environement)
         - La commande env
         - Locale à une commande
       - Les variables d'environnements importantes
       - Les paramètres
       - Les sous-shell
       - Les expressions mathématiques $(()) ou $[]
    - L'escaping et le quoting
      - \
      - "
      - '
      - /!\ `
    - Le terminal
      - C'est le bordel
      - $TERM
      - Ctrl+V
      - Mode graphique
      - Les bindings de touches:
        - VT102 -> Infernal
        - Meta-q, Ctrl+gauche, ....
    - Les alias           
    - Le globbing
      - Les deux exception: find et dpkg
    - ~ et les braces         
    - Grep et les expression régulière
    - ed, sed, vi, emacs, vim, nano
    - awk, perl
    - Les scripts
      - Les sourcing
      - Les fonctions
    - Les jobs
      - fg/bg, etc...
    - La completion
      - La completion avancée
    - La documentation: man, Meta-H


    - Le réseau
      - /etc/resolv.conf
      - Les proxy DNS -> /run/nm...
      - route -n
      - ifconfig
      - iproute2
      - iptable/netfilter
    - Travailler à distance
      - telnet / tcpdump / arp floding
      - ssh
      - ssh-agent
      - ssh-askpass
      - Les tunnel
      - Les tunnel proxy
      - Les interface virtuelle
    - Les utilisateurs
       - root
       - Passer root
       - Les droits
       - chmod
       - Les groupes
       - les UID/GID, /etc/passwd /etc/group
       - Stickybit
       - SetUID -> /bin/ping
    - Un peu d'administration:
       - tar.gz/cpio / dpkg (-i -l -L -S) / rpm (-i -q) / ipk
       - apt-get / urpmi / yum
       - apt-cache, apt-get source, apt-get source -b, apt-get builddeps, etc...
    - Les différents fichiers de configuration -> A mettre dans l'arborescence
       - .Xshrc
       - /etc/*.conf

  - L'arborescence -> 2h
    - Les différents fichiers: normaux, repertoire, liens, des filedevice characters, des filedevice block, des pipe, des socket nommées.
    - Les seuls carcatère interdits sont / et \0
    - /usr/bin /bin /usr/sbin /sbin
      - Séparation /usr et /
      - Séparation bin et sbin
    - /lib* /usr/lib* -> Qu'est-ce qu'une bibliothèque?
    - /etc
    - /usr/share /usr/share/doc /usr/share/man
    - /var, /var/run, /run, /var/cache, /var/spool, /var/lib
    - /dev
      - filedevice: tout est fichier
      - /dev/sda -> octet du disque
        - commande dd permet de lire en specifiant des offset et des taille de lecture
      - /dev/sr0
      - /dev/ttyS0 -> port serie
      - pseudo device: /dev/null
      - /dev/random
      - /dev/zero
      - /dev/mem
      - /dev/psaux /dev/input/*
      - /dev/snd/
      - Plus pseciaux: /dev/rtc
      - Encore plus speciaux: /dev/video0, /dev/nvidia: nous y reviendrons lorsque nous travailloerons sur les drivers
      - N'apparaissent pas: 
        - Les bus (cas très rare et anormaux ou on fait des implementation en userland), 
        - Les cartes et les périphériques réseaux (à l'heure du cloud et des environnement distribué, ca peut avoir son importance)
      - Les carte video n'apparaissent pas toujours. Certains driver sont implémentés en userspace
      - Les filedecriptor
        - Sur des fichier
        - Autre appel système utilisant des filedescriptor
    - Les filesystems
      - point de montage
      - /mnt
      - mount
      - mount -o loop
      - /proc et /sys
      - Filesystems réseau: nfs, samba
      - Normallement implementé par le noyau, mais peut etre implemneté dans l'espace utilisateur avec fuse (/dev/fuse)
    - debootstrap
    - ./configure --prefix=
    - Au dela de la normalisation: /opt, /usr/local
    - Est-ce que l'on doit expliquer comment fonctionne les fichiers en interne:
       - vfat
       - ext2
    - Nom de fichiers authorisé sous *nix: tous les caractère sauf / et NUL
    - Systeme de fichier journalisé: en quoi ca consiste
    - Les système COW, unionfs, en quoi ca consiste
  - La compilation
    - Makefile
      - target: deps
      - Regles implicites
      - Variables standards
      - Passer les varaible standard: par l'env, en arguments
      - Dépendance avec les .h
      - Avoir plusieurs configurations
    - Autotools
      - configure + Makefile, etc..
      - Compiler avec ces outils
      - Exemple d'utilisation de ./configure
      - Création d'un projet Autotools
    - Compatibilité avec les OS non Posix (fonctionne avec Cygwin)
      - Alternatives:
        - Cmake
    - Complexité et gestion des multiples options
      - Kmake
    - les fichiers generés par la compilation:
      - *.c *.h *.d *.o *.so ELF
    - Utilisation correcte des bibliothèques:
      - .so + .h
      - packet de dev vs packet de prod
    - ldconfig
    - libtools, LD_LIBRARY_PATH, LD_PRELOAD, 

    - linker: ld                             -> Il faut peut-être faire l'architecture de la mémoire avant -> Et avant la memoire, il faut voir les process
    - A-t-on le droit de se linker avec la biliotheque: parlon sdes licences
      - GPL, etc...
  - Les tâches
    - monotache
    - Les interruptions
      - Les PICs
      - Le multiplexing d'interruption
    - Foregrund/Background
    - Le temps partagé = concurrence != parallèle
    - Le multitache non-préemptif
      - Le context-switching
    - Le multitache préemptif -> HZ, dynamic HZ
    - La gestion de la mémoire en multitâche
      - La MMU
      - Addresse virtuelle/ Addresse phyique
      - Le segfault
      - L'allocation -> sbrk ou mmap
      - Le passage usermode -> kernelmode
      - les appels système
         - Dans le noyau
         - Dans la libc
         - Le swap sw contexte, la problèmatique des accès concurrant
      - mmap
      - Le cache
      - Copy On Write
      - Le swap, la swapiness
      - La compression de la mémoire
      - Le merging de page
      - La gestion du cache d'instruction et du cache de donnée
      - Le TLB
  - La gestion de la mémoire
     - En user space
       - La pile, le tas, les variable globale
       - Structure de la pile
       - L'allogrithme de malloc
       - Allocon sur la pile: Alloca et "char buf[i];"
       - D'autres algorithme
       - Les technique de debug
         - libefence
         - DUMA
         - Valgrind
     - En kernelspace
       - kmalloc, vmalloc, la memoire haute, 
       - Le mapping mémoire du noyau
       - Le SLAB
       - memcheck
       - mem(l'autre que memcheck)
     - Allocation mémoire et predictabilité
  - Format des fichiers ELF -> A faire après la memoire
    - Autre format : COFF, PE/COFF (windows), COM
      - Le format COM: pas de header. Chargé en 0x100
      - relocation des .o:
           -  A la compilation, le compilateur rempli les addresses nons résolue avec 0 et ajoute une entrée dans la table des relocation. cette entré contient l'offset ou ce trouve l'indirection et le symbole attendu (avec eventuellement un offset)
      - Les DLL: contiennent une table de relocation et sont résolut à l'éxecution (en fait, il y a une adresse par defaut, si celle ci marche, pas besoin de relocaliser)
         - Probleme: Comment partager le code la dll entre les processus qui l'utilise à des addresse differentes
         - ... pas de réponse. Sous windows, les bibliothèque partagée ne sont pas partagée (en fait, elle sont partagée uniquement si ce sont deux instances de la même binaire). -> Perte de mémoire. C'est aussi pour cette raison que les applications n'hésitent pas à livrer leur version de bibliothèque
      - PIC
         -> Pour du code, on fait du relatif à pc
         -> b 0x10 -> b pc+0x5
         -> Pour la variable globale, il faut ajouter une indirection que l'on place dans la Global Object Table 
         -> ld r1,$0x10 -> ld r1, $(pc+0x42+0x5)
                                   ^^^^ ^^^
                                     |    `- offset de la variable dans la GOT
                                     `- offset de la GOT
      - Randomization de la mémoire (heap et lib) (sécurité)
    - Script de link (c'est la suite de la compilation, mais apres avoir compris le fonctionnement de la MMU)
    - Format d'appel des fonctions
    - resolution dynamique des symboles, LD_PRELOAD, LD_LIBRARY_PATH
    - sections
    - les symboles  -> objdump
    - les symboles/sections de debug -> objcopy, strip
    - Comment fonctionne un debuggeur? -> gdb 
      - Coredump
      - ulimit -c unlimited
      - echo /tmp/core | sudo tee /proc/sys/kernel/core_pattern
      - objdump -x sur le coredump
      - host/target
    - Comment fonctionne une sonde JTAG? -> openocd
    - Les probe
    - La couverture de code
    - gperf
    - perf/oprofile
    - dynamic printk
    - strace/ltrace
    - Les autres outils pour la qualité des devs système
       - diff /patch
       - patchutils
       - quilt
       - svn
       - git -> github
       - L'intégration continue
       - Le codingstyle du noyau
         - astyle, indent, utilisez un vrai editeur
       - La revue de code
       - Les certifications
  - La communication interprocessus
    - La communication inter thread
      - Problematique:
        - Memoire partagée
        - Pariphérique partagée
      - Les buffers ciculaires
      - Les mutex
      - Les semaphore
      - Les rendez-vous
      - Les spin-lock
      - Les condition
      - Les RCU et autres algo sioux
    - Les signaux
      - les signaux temps réel
    - Les SHM -> /!\ Alllocation
    - Les mq
    - Les sem
      -> Et tout ca, c'est tout pourris
      -> Allez vois Xenomai
  - Les drivers;
    - en monotache -> = une bibliothèque, avec eventuellement, une gestion d'interruption (msdos)
    - en multitache -> gere les accès conurrent
    - Les drivers sous Linux: des char device
    - Les major et les minor
    - copytouser, copy fromuser
    - Compiler les driver, dans le kernel, a l'exterieur du kernel
    - on revient sur le filedescriptor
    - Mapper des registres en mémoire
      - POssible en espace utilisateur avec mmap sur /dev/mem
      - C'est la raison pour laquelle, il n'y a pas de device pour les carte graphique
    - Allouer une interruption, return IRQ_HANDLED et multiplexage
      -> Soft IRQ
      [Reprendre la parte du cours ``L'API'', wait queue, etc...]
    - Les DMA
      - Comment ca marche
    - Exemple: Fonctionnement d'une STB sans copie de mémoire
    - Debug des drivers
      - kgdb
      - etc...
  - Les API et les archtectures d'OS
    - système de linux:
       - inotify, fanotify
       - timerfd
       - signalfd
       - eventfd
       - Gestion des utilisateurs
       - Gestion de l'heure
       - Gestion des fichier
       - Gestion de file descriptor et gestion du réseau: ~ read/write, mais spécialiste dans le réseau -> ca reste des file descriptor
     - système sous Windows
       - 
     - Sous Hurd 
  - La virtualisation
     - Plusieurs type
        - Complete
        - Noyau seulement
        - Hyperviseur
     - L'interpretation
     - La JIT
        - Tehcnique provenant du bytecode
     - L'acceraltion matérielle du MMU
     - Architecture de Virtual Box
     - Architecture de VMWar hypervisor
  - Le boot
     - La ROM
     - La flash
     - Les bootloader: bios, grub, isolinux, uboot, etc..
     - Le noyau, eXecute In Place, la decompression
     - Apres le boot du noyau
       - SysV
       - upstart 
       - runit
       - systemd
     - Le boot par réseau
     - Le boot NFS
     - Le plugnplay, Le format DTS/openfirmware
     

  - Travailler en embarqué
    - La cross compilation
      - Le host/la target
      - Avec Make
      - Avec Autotools
    - Busybox
    - Compiler la tool chain
      - Yann
    - Compiler le noyau
      [plein de choses à dire]
    - Créer le filesystem. 
      - JFFS2
    - Le recopier sur la flash 
    - Monter en local l'image JFFS2
    - Buildroot
    - Qemu + scratchbox
    - 
